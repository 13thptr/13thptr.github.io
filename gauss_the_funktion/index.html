<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>FUNKTION DER GAUSS</title>
</head>
<body>
	<h2>Guess the function</h2>
	<canvas id="c1" style="position:absolute;left:0px;top:60px;z-index:0;"width="768" height="512"></canvas>
	<canvas id="c2" style="position:absolute;left:0px;top:60px;z-index:1;"width="768" height="512"></canvas>
	<button id="fl" style="position:absolute;left:10px;top:595px">Hide arrows</button>
	<button id="cl" style="position:absolute;left:10px;top:625px">Show circles</button>
	<!--<p id="coefsp" style="position:absolute;left:10px;top:600px"> de coefficients:1000 (Note:modifier les valeurs ci-dessous redémarre l'animation)Nombre</p>-->
	<!--<input id="coefsNb" type="range" min="1" max="1000" style="position:absolute;left:10px;top:655px">-->
	<script src="libcmplx.js"></script>
	<!--Points (échantillons de la fonction complexe)-->
	<script src="coords.js"></script>
	<!--Script pour la gestion des entrees/fichiers,etc.-->
	<script src="libutil.js"></script>

	<script>
	let ZOOM=20;
	let frame=0;
	let t=0;
	const CENTRE_X=c1.width/2;
	const CENTRE_Y=c1.height/2;
	//Todo:Transformée de Fourier rapide (FFT)

	//const NOMBRE_COEFS=1000;//Nombre de coefficients
	let coefficients=TFD(reformate,NOMBRE_COEFS);
	//Dans la fonction suivante, a et b  sont de la forme [z_n,n] où z_n est  un complexe sous forme de liste
	//et n l'indice original du coefficient z_n (important pour la transformation inverse) 
	function compare(a,b){
		return moduleCarre(b[0])-moduleCarre(a[0]);
	}
	coefficients.sort(compare);
	x1.fillStyle="black"	
	//fond noir pour le canevas n°1 (le noir est la couleur par défaut de la méthode fillRect- EDIT:mis quand même la précision)
	x1.fillRect(0,0,1024,1024);
	//une fois le rectangle/fond affiché, on change la couleur de remplissage 
	x1.strokeStyle="#0dfca1";

	let X=Y=tmpX=tmpY=0;
	let angle=0;
	x2.fillStyle="#fff";//blanc (flèches)
	x2.strokeStyle="#0af6";//bleu clair(cercles)
	x2.lineWidth=3;
	const TAU=2*Math.PI;

	function anim(){
		x2.clearRect(0,0,c2.width,c2.height);//On efface le contenu du canevas
		angle=TAU*frame*VITESSE/NOMBRE_COEFS;
		let z=[0,0];
		//let tmpX=X;
		//let tmpY=Y;
		for(let n=1;n<NOMBRE_COEFS;n++){
			//On omet la composante continue qui n'est qu'un décalage.
			let vecteur_courant=mult(coefficients[n][0],e(angle*coefficients[n][1]));
			let mod=module(vecteur_courant);
			let arg=argument(vecteur_courant);

			tmpX=z[0]+CENTRE_X;
			tmpY=z[1]+CENTRE_Y;

			if(cl_toggled){
				x2.beginPath();
				x2.arc(tmpX,tmpY,mod,0,TAU);
				x2.stroke();
			}
			if(fl_toggled){
				//On déplace le centre du canevas sur le point courant qui va être la base de la flèche
				x2.translate(tmpX,tmpY);
				x2.rotate(arg-Math.PI/2);//Elucider la constante ?-> Liée à l'inversion du repère ? ((Oy) vers le bas )
				x2.fill(new Path2D(fleche(0,0,mod)));//On dessine la flèche
				//On rétablit la matrice de transformation(->identité) du canevas
				//ce qui annule la rotation et la translation appliquées auparavant
				x2.setTransform(1,0,0,1,0,0);
			}
			z=ajoute(z,vecteur_courant);
		}
		//Tracé d'un segment entre M(t) et M(t+dt).
		x1.beginPath();
		x1.moveTo(X,Y);
		X=z[0]+CENTRE_X;
		Y=z[1]+CENTRE_Y;
		x1.lineTo(X,Y);
		x1.stroke();
		frame++;
		t=frame/60;
		requestAnimationFrame(anim);
	}
	anim();
	</script>
</body>
</html>
